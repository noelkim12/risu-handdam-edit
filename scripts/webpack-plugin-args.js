/**
 * Webpack Plugin for Auto-generating Plugin Args Configuration
 *
 * This plugin:
 * 1. Reads plugin-args.json
 * 2. Generates src/core/plugin-config.js with getter/setter helpers
 * 3. Returns @arg entries for webpack banner
 */

const fs = require('fs');
const path = require('path');

class PluginArgsWebpackPlugin {
  constructor(options = {}) {
    this.argsFilePath = options.argsFilePath || path.resolve(__dirname, '../src/plugin-args.json');
    this.outputFilePath = options.outputFilePath || path.resolve(__dirname, '../src/core/plugin-config.js');
  }

  apply(compiler) {
    // Watch plugin-args.json for changes
    compiler.hooks.beforeCompile.tapAsync('PluginArgsWebpackPlugin', (params, callback) => {
      try {
        this.generatePluginConfig();
        callback();
      } catch (error) {
        callback(error);
      }
    });

    // Add plugin-args.json to watched files
    compiler.hooks.afterCompile.tap('PluginArgsWebpackPlugin', (compilation) => {
      // Add JSON file to compilation dependencies so webpack watches it
      compilation.fileDependencies.add(this.argsFilePath);
    });
  }

  /**
   * Read plugin-args.json and generate plugin-config.js
   */
  generatePluginConfig() {
    // 1. Read args definition
    if (!fs.existsSync(this.argsFilePath)) {
      console.warn(`[PluginArgsWebpackPlugin] ${this.argsFilePath} not found. Skipping plugin-config.js generation.`);
      return;
    }

    const argsConfig = JSON.parse(fs.readFileSync(this.argsFilePath, 'utf8'));
    const args = argsConfig.args || [];

    if (args.length === 0) {
      console.warn('[PluginArgsWebpackPlugin] No args defined in plugin-args.json.');
      return;
    }

    // 2. Generate code
    const code = this.generateCode(args);

    // 3. Write to file
    fs.writeFileSync(this.outputFilePath, code, 'utf8');
    console.log(`[PluginArgsWebpackPlugin] Generated ${this.outputFilePath} with ${args.length} args.`);
  }

  /**
   * Generate PluginArgs class code
   * @param {Array} args - Array of arg definitions
   * @returns {string} Generated JavaScript code
   */
  generateCode(args) {
    const getters = args.map(arg => this.generateGetter(arg)).join('\n\n');
    const setters = args.map(arg => this.generateSetter(arg)).join('\n\n');

    return `/**
 * Auto-generated Plugin Arguments Configuration
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * This file is automatically generated from src/plugin-args.json during webpack build.
 *
 * To add/modify plugin arguments:
 * 1. Edit src/plugin-args.json
 * 2. Run npm run build
 * 3. This file will be regenerated automatically
 *
 * Generated at: ${new Date().toISOString()}
 */

import { PLUGIN_NAME } from '../constants.js';
import { RisuAPI } from './risu-api.js';

/**
 * Plugin Arguments Helper Class
 * Provides convenient getter/setter access to RisuAI plugin arguments with caching.
 * Automatically uses RisuAPI singleton instance.
 *
 * @example
 * import { PluginArgs } from './core/plugin-config.js';
 *
 * const args = new PluginArgs();
 *
 * // Getter
 * const apiKey = args.exampleApiKey;
 *
 * // Setter
 * args.maxTokens = 4096;
 *
 * // Cache invalidation
 * args.invalidate('exampleApiKey');
 */
export class PluginArgs {
  /**
   * @param {Object} [risuAPI] - RisuAPI instance (optional, uses singleton if not provided)
   */
  constructor(risuAPI = null) {
    // Use singleton instance if not provided
    this._api = risuAPI || RisuAPI.getInstance();
    this._cache = new Map();
    this._ttl = 5000; // Cache TTL in milliseconds (5 seconds)
    this._timestamps = new Map();
  }

  // ==================== Auto-generated Getters ====================

${getters}

  // ==================== Auto-generated Setters ====================

${setters}

  // ==================== Private Helper Methods ====================

  /**
   * Get argument value with caching
   * @private
   * @param {string} name - Argument name
   * @param {string|number} defaultValue - Default value
   * @returns {string|number} Argument value
   */
  _get(name, defaultValue) {
    const key = \`\${PLUGIN_NAME}::\${name}\`;
    const now = Date.now();

    // Check cache validity
    if (this._cache.has(key)) {
      const timestamp = this._timestamps.get(key);
      if (timestamp && (now - timestamp) < this._ttl) {
        return this._cache.get(key);
      }
    }

    // Fetch from API
    const value = this._api.getArg(key) ?? defaultValue;
    this._cache.set(key, value);
    this._timestamps.set(key, now);
    return value;
  }

  /**
   * Set argument value and update cache
   * @private
   * @param {string} name - Argument name
   * @param {string|number} value - Argument value
   */
  _set(name, value) {
    const key = \`\${PLUGIN_NAME}::\${name}\`;
    this._api.setArg(key, value);
    this._cache.set(key, value);
    this._timestamps.set(key, Date.now());
  }

  // ==================== Public Cache Management ====================

  /**
   * Invalidate cache for a specific argument
   * @param {string} name - Argument name
   */
  invalidate(name) {
    const key = \`\${PLUGIN_NAME}::\${name}\`;
    this._cache.delete(key);
    this._timestamps.delete(key);
  }

  /**
   * Clear all cached values
   */
  clearCache() {
    this._cache.clear();
    this._timestamps.clear();
  }

  /**
   * Set cache TTL (Time To Live)
   * @param {number} ttl - TTL in milliseconds
   */
  setCacheTTL(ttl) {
    if (typeof ttl !== 'number' || ttl < 0) {
      throw new Error('TTL must be a non-negative number');
    }
    this._ttl = ttl;
  }

  /**
   * Get all cached argument names
   * @returns {string[]} Array of cached argument names
   */
  getCachedArgs() {
    return Array.from(this._cache.keys()).map(key => key.replace(\`\${PLUGIN_NAME}::\`, ''));
  }
}
`;
  }

  /**
   * Generate getter code for an argument
   * @param {Object} arg - Argument definition
   * @returns {string} Getter code
   */
  generateGetter(arg) {
    const { name, type, default: defaultValue, description } = arg;
    const jsDefault = type === 'int' ? defaultValue : JSON.stringify(defaultValue);

    return `  /**
   * Get ${name}
   * ${description}
   * @type {${type === 'int' ? 'number' : 'string'}}
   */
  get ${name}() {
    return this._get('${name}', ${jsDefault});
  }`;
  }

  /**
   * Generate setter code for an argument
   * @param {Object} arg - Argument definition
   * @returns {string} Setter code
   */
  generateSetter(arg) {
    const { name, type, description } = arg;
    const validation = type === 'int'
      ? `    if (typeof value !== 'number') {
      throw new TypeError('${name} must be a number');
    }`
      : `    if (typeof value !== 'string') {
      throw new TypeError('${name} must be a string');
    }`;

    return `  /**
   * Set ${name}
   * ${description}
   * @param {${type === 'int' ? 'number' : 'string'}} value - New value
   */
  set ${name}(value) {
${validation}
    this._set('${name}', value);
  }`;
  }
}

/**
 * Helper function to generate banner @arg entries
 * @param {string} argsFilePath - Path to plugin-args.json
 * @returns {string} Banner @arg entries
 */
function generateBannerArgs(argsFilePath) {
  if (!fs.existsSync(argsFilePath)) {
    return '';
  }

  const argsConfig = JSON.parse(fs.readFileSync(argsFilePath, 'utf8'));
  const args = argsConfig.args || [];

  if (args.length === 0) {
    return '';
  }

  return args
    .map(arg => `//@arg ${arg.name} ${arg.type}`)
    .join('\n');
}

module.exports = {
  PluginArgsWebpackPlugin,
  generateBannerArgs,
};
