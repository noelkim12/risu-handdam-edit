/**
 * Webpack Plugin for Development Mode Hot Reload
 *
 * This plugin:
 * 1. Detects development mode (NODE_ENV=development)
 * 2. Reads actual port from .dev-server-port file
 * 3. Auto-generates src/core/dev-reload.js with WebSocket client code
 * 4. Adds @dev-mode and @dev-server to webpack banner
 * 5. Only activates in development mode (production builds are unaffected)
 */

const fs = require('fs');
const path = require('path');

class DevModeWebpackPlugin {
  constructor(options = {}) {
    this.defaultPort = options.defaultPort || 13131;
    this.portFilePath = options.portFilePath || path.resolve(__dirname, '../.dev-server-port');
    this.outputFilePath = options.outputFilePath || path.resolve(__dirname, '../src/core/dev-reload.js');
    this.isDevelopment = process.env.NODE_ENV === 'development';
    this.actualPort = this.getActualPort();
    this.wssUrl = `ws://localhost:${this.actualPort}`;
  }

  /**
   * Read actual port from .dev-server-port file
   * @returns {number} Actual port number
   */
  getActualPort() {
    try {
      if (fs.existsSync(this.portFilePath)) {
        const portStr = fs.readFileSync(this.portFilePath, 'utf8').trim();
        const port = parseInt(portStr, 10);
        if (!isNaN(port) && port > 0) {
          console.log(`[DevModePlugin] Using port from file: ${port}`);
          return port;
        }
      }
    } catch (error) {
      console.warn('[DevModePlugin] Failed to read port file:', error.message);
    }

    console.log(`[DevModePlugin] Using default port: ${this.defaultPort}`);
    return this.defaultPort;
  }

  apply(compiler) {
    // Only activate in development mode
    if (!this.isDevelopment) {
      console.log('[DevModePlugin] Production mode - skipping dev-reload.js generation');

      // Clean up dev-reload.js if it exists
      if (fs.existsSync(this.outputFilePath)) {
        fs.unlinkSync(this.outputFilePath);
        console.log('[DevModePlugin] Removed dev-reload.js for production build');
      }

      return;
    }

    // Generate dev-reload.js once before the first compilation
    let isFirstCompilation = true;

    compiler.hooks.beforeCompile.tapAsync('DevModeWebpackPlugin', (params, callback) => {
      try {
        // Only generate on first compilation to prevent infinite loop
        if (isFirstCompilation) {
          this.generateDevReloadScript();
          isFirstCompilation = false;
        }
        callback();
      } catch (error) {
        callback(error);
      }
    });

    // DO NOT add dev-reload.js to watched files - this causes infinite loop!
    // The file is auto-generated and should not trigger rebuilds

    console.log('[DevModePlugin] Development mode - hot reload enabled');
  }

  /**
   * Generate dev-reload.js with WebSocket client code
   */
  generateDevReloadScript() {
    const code = this.generateClientCode();

    // Ensure directory exists
    const dir = path.dirname(this.outputFilePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(this.outputFilePath, code, 'utf8');
    console.log(`[DevModePlugin] Generated ${this.outputFilePath}`);
  }

  /**
   * Generate WebSocket client code
   * @returns {string} Generated JavaScript code
   */
  generateClientCode() {
    return `/**
 * Auto-generated Hot Reload Client
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * This file is automatically generated in development mode.
 *
 * Generated at: ${new Date().toISOString()}
 * WebSocket URL: ${this.wssUrl}
 */

import { parsePluginScript, scriptUpdater } from './script-updater.js';

const DEV_SERVER_URL = '${this.wssUrl}';
const MAX_RECONNECT_DELAY = 30000; // 30 seconds
const INITIAL_RECONNECT_DELAY = 1000; // 1 second
const MAX_ERROR_LOGS = 3; // Maximum error logs to display

class HotReloadClient {
  constructor() {
    this.ws = null;
    this.reconnectAttempts = 0;
    this.reconnectTimeout = null;
    this.isIntentionallyClosed = false;
    this.errorLogCount = 0; // Track error log count
  }

  /**
   * Initialize WebSocket connection
   */
  connect() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      console.log('[HotReload] Already connected');
      return;
    }

    try {
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        console.log('[HotReload] Connecting to dev server:', DEV_SERVER_URL);
      }
      this.ws = new WebSocket(DEV_SERVER_URL);

      this.ws.onopen = () => {
        console.log('[HotReload] âœ… Connected to dev server');
        this.reconnectAttempts = 0; // Reset on successful connection
        this.errorLogCount = 0; // Reset error log count on successful connection
      };

      this.ws.onmessage = (event) => {
        this.handleMessage(event.data);
      };

      this.ws.onclose = (event) => {
        if (this.errorLogCount < MAX_ERROR_LOGS) {
          console.log(\`[HotReload] Disconnected (code: \${event.code}, reason: \${event.reason || 'unknown'})\`);
          this.errorLogCount++;
        } else if (this.errorLogCount === MAX_ERROR_LOGS) {
          console.log('[HotReload] Connection errors suppressed (max logs reached). Retrying silently...');
          this.errorLogCount++;
        }

        if (!this.isIntentionallyClosed) {
          this.scheduleReconnect();
        }
      };

      this.ws.onerror = (error) => {
        if (this.errorLogCount < MAX_ERROR_LOGS) {
          console.error('[HotReload] WebSocket error:', error.message || error);
        }
      };

    } catch (error) {
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        console.error('[HotReload] Connection failed:', error);
        this.errorLogCount++;
      }
      this.scheduleReconnect();
    }
  }

  /**
   * Handle incoming messages from dev server
   * @param {string} data - Raw message data
   */
  handleMessage(data) {
    try {
      const message = JSON.parse(data);

      switch (message.type) {
        case 'connected':
          console.log('[HotReload] Server message:', message.message);
          break;

        case 'reload':
          console.log(\`[HotReload] ðŸ“¦ Update received (\${message.file}, \${message.size} bytes)\`);
          this.handleReload(message.scriptContent);
          break;

        case 'pong':
          // Heartbeat response (optional)
          break;

        default:
          console.warn('[HotReload] Unknown message type:', message.type);
      }
    } catch (error) {
      console.error('[HotReload] Failed to parse message:', error);
    }
  }

  /**
   * Handle script reload
   * @param {string} scriptContent - Updated script content
   */
  async handleReload(scriptContent) {
    try {
      console.log('[HotReload] ðŸ”„ Parsing updated script...');

      // Parse using existing script-updater logic
      const parsed = parsePluginScript(scriptContent);

      console.log('[HotReload] ðŸ”„ Updating plugin...');
      const result = await scriptUpdater(parsed);

      if (result.success) {
        console.log('[HotReload] âœ… Plugin updated successfully');

        // Show toast notification instead of auto-reload
        this.showToast('ðŸ”¥ Hot Reload Complete!', 'success');
      } else {
        console.error('[HotReload] âŒ Plugin update failed:', result.error);
        this.showToast(\`âŒ Hot Reload Failed: \${result.error?.message || 'Unknown error'}\`, 'error');
      }
    } catch (error) {
      console.error('[HotReload] âŒ Reload failed:', error);
      this.showToast(\`âŒ Hot Reload Error: \${error.message}\`, 'error');
    }
  }

  /**
   * Show toast notification
   * @param {string} message - Toast message
   * @param {string} type - Toast type ('success' or 'error')
   */
  showToast(message, type = 'success') {
    // Remove existing toast if any
    const existingToast = document.getElementById('hot-reload-toast');
    if (existingToast) {
      existingToast.remove();
    }

    // Create toast element
    const toast = document.createElement('div');
    toast.id = 'hot-reload-toast';
    toast.textContent = message;

    // Apply styles
    const bgColor = type === 'success' ? '#10b981' : '#ef4444';
    Object.assign(toast.style, {
      position: 'fixed',
      top: '-100px', // Start above viewport
      left: '50%',
      transform: 'translateX(-50%)',
      backgroundColor: bgColor,
      color: 'white',
      padding: '12px 24px',
      borderRadius: '8px',
      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.06)',
      fontSize: '14px',
      fontWeight: '500',
      zIndex: '999999',
      transition: 'top 0.3s ease-out',
      fontFamily: 'system-ui, -apple-system, sans-serif',
    });

    // Append to body
    document.body.appendChild(toast);

    // Trigger slide down animation
    setTimeout(() => {
      toast.style.top = '20px';
    }, 10);

    // Auto remove after 3 seconds
    setTimeout(() => {
      toast.style.top = '-100px';
      setTimeout(() => {
        toast.remove();
      }, 300); // Wait for slide up animation
    }, 3000);
  }

  /**
   * Schedule reconnection with exponential backoff
   */
  scheduleReconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
    const delay = Math.min(
      INITIAL_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts),
      MAX_RECONNECT_DELAY
    );

    if (this.errorLogCount < MAX_ERROR_LOGS) {
      console.log(\`[HotReload] Reconnecting in \${delay / 1000}s... (attempt \${this.reconnectAttempts + 1})\`);
    }

    this.reconnectTimeout = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  /**
   * Send ping to server (optional heartbeat)
   */
  ping() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
    }
  }

  /**
   * Disconnect from server
   */
  disconnect() {
    this.isIntentionallyClosed = true;

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    if (this.ws) {
      this.ws.close(1000, 'Client closed');
      this.ws = null;
    }

    console.log('[HotReload] Disconnected');
  }
}

// Singleton instance
let hotReloadClient = null;

/**
 * Initialize hot reload client
 */
export function initHotReload() {
  if (hotReloadClient) {
    console.log('[HotReload] Already initialized');
    return hotReloadClient;
  }

  console.log('[HotReload] ðŸ”¥ Initializing hot reload client...');
  hotReloadClient = new HotReloadClient();
  hotReloadClient.connect();

  // Optional: Send ping every 30 seconds to keep connection alive
  setInterval(() => {
    hotReloadClient.ping();
  }, 30000);

  return hotReloadClient;
}

/**
 * Disconnect hot reload client
 */
export function stopHotReload() {
  if (hotReloadClient) {
    hotReloadClient.disconnect();
    hotReloadClient = null;
  }
}
`;
  }
}

/**
 * Get development mode banner metadata
 * @returns {string} Banner metadata for dev mode
 */
function getDevModeBanner() {
  const isDevelopment = process.env.NODE_ENV === 'development';

  if (!isDevelopment) {
    return '';
  }

  // Read actual port from file
  let actualPort = 13131;
  try {
    const portFilePath = path.resolve(__dirname, '../.dev-server-port');
    if (fs.existsSync(portFilePath)) {
      const portStr = fs.readFileSync(portFilePath, 'utf8').trim();
      const port = parseInt(portStr, 10);
      if (!isNaN(port) && port > 0) {
        actualPort = port;
      }
    }
  } catch (error) {
    // Fallback to default port
  }

  return `//@dev-mode true
//@dev-server ws://localhost:${actualPort}`;
}

module.exports = {
  DevModeWebpackPlugin,
  getDevModeBanner,
};
