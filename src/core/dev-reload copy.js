/**
 * Auto-generated Hot Reload Client
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * This file is automatically generated in development mode.
 *
 * Generated at: 2025-11-12T14:33:58.371Z
 * WebSocket URL: wss://ws.noelkim12.dev/ws
 */

import { parsePluginScript, scriptUpdater } from './script-updater.js';

const DEV_SERVER_URL = 'wss://ÎÇ¥ÎèÑÎ©îÏù∏/ws';
const MAX_RECONNECT_DELAY = 30000; // 30 seconds
const INITIAL_RECONNECT_DELAY = 1000; // 1 second
const MAX_ERROR_LOGS = 3; // Maximum error logs to display

class HotReloadClient {
  constructor() {
    this.ws = null;
    this.reconnectAttempts = 0;
    this.reconnectTimeout = null;
    this.isIntentionallyClosed = false;
    this.errorLogCount = 0; // Track error log count
  }

  /**
   * Initialize WebSocket connection
   */
  connect() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      console.log('[HotReload] Already connected');
      return;
    }

    try {
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        console.log('[HotReload] Connecting to dev server:', DEV_SERVER_URL);
      }
      this.ws = new WebSocket(DEV_SERVER_URL);

      this.ws.onopen = () => {
        console.log('[HotReload] ‚úÖ Connected to dev server');
        this.reconnectAttempts = 0; // Reset on successful connection
        this.errorLogCount = 0; // Reset error log count on successful connection
      };

      this.ws.onmessage = (event) => {
        this.handleMessage(event.data);
      };

      this.ws.onclose = (event) => {
        if (this.errorLogCount < MAX_ERROR_LOGS) {
          console.log(`[HotReload] Disconnected (code: ${event.code}, reason: ${event.reason || 'unknown'})`);
          this.errorLogCount++;
        } else if (this.errorLogCount === MAX_ERROR_LOGS) {
          console.log('[HotReload] Connection errors suppressed (max logs reached). Retrying silently...');
          this.errorLogCount++;
        }

        if (!this.isIntentionallyClosed) {
          this.scheduleReconnect();
        }
      };

      this.ws.onerror = (error) => {
        if (this.errorLogCount < MAX_ERROR_LOGS) {
          console.error('[HotReload] WebSocket error:', error.message || error);
        }
      };

    } catch (error) {
      if (this.errorLogCount < MAX_ERROR_LOGS) {
        console.error('[HotReload] Connection failed:', error);
        this.errorLogCount++;
      }
      this.scheduleReconnect();
    }
  }

  /**
   * Handle incoming messages from dev server
   * @param {string} data - Raw message data
   */
  handleMessage(data) {
    try {
      const message = JSON.parse(data);

      switch (message.type) {
        case 'connected':
          console.log('[HotReload] Server message:', message.message);
          break;

        case 'reload':
          console.log(`[HotReload] üì¶ Update received (${message.file}, ${message.size} bytes)`);
          this.handleReload(message.scriptContent);
          break;

        case 'pong':
          // Heartbeat response (optional)
          break;

        default:
          console.warn('[HotReload] Unknown message type:', message.type);
      }
    } catch (error) {
      console.error('[HotReload] Failed to parse message:', error);
    }
  }

  /**
   * Handle script reload
   * @param {string} scriptContent - Updated script content
   */
  async handleReload(scriptContent) {
    try {
      console.log('[HotReload] üîÑ Parsing updated script...');

      // Parse using existing script-updater logic
      const parsed = parsePluginScript(scriptContent);

      console.log('[HotReload] üîÑ Updating plugin...');
      const result = await scriptUpdater(parsed);

      if (result.success) {
        console.log('[HotReload] ‚úÖ Plugin updated successfully');

        // Show toast notification instead of auto-reload
        this.showToast('üî• Hot Reload Complete!', 'success');
      } else {
        console.error('[HotReload] ‚ùå Plugin update failed:', result.error);
        this.showToast(`‚ùå Hot Reload Failed: ${result.error?.message || 'Unknown error'}`, 'error');
      }
    } catch (error) {
      console.error('[HotReload] ‚ùå Reload failed:', error);
      this.showToast(`‚ùå Hot Reload Error: ${error.message}`, 'error');
    }
  }

  /**
   * Show toast notification
   * @param {string} message - Toast message
   * @param {string} type - Toast type ('success' or 'error')
   */
  showToast(message, type = 'success') {
    // Remove existing toast if any
    const existingToast = document.getElementById('hot-reload-toast');
    if (existingToast) {
      existingToast.remove();
    }

    // Create toast element
    const toast = document.createElement('div');
    toast.id = 'hot-reload-toast';
    toast.textContent = message;

    // Apply styles
    const bgColor = type === 'success' ? '#10b981' : '#ef4444';
    Object.assign(toast.style, {
      position: 'fixed',
      top: '-100px', // Start above viewport
      left: '50%',
      transform: 'translateX(-50%)',
      backgroundColor: bgColor,
      color: 'white',
      padding: '12px 24px',
      borderRadius: '8px',
      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.06)',
      fontSize: '14px',
      fontWeight: '500',
      zIndex: '999999',
      transition: 'top 0.3s ease-out',
      fontFamily: 'system-ui, -apple-system, sans-serif',
    });

    // Append to body
    document.body.appendChild(toast);

    // Trigger slide down animation
    setTimeout(() => {
      toast.style.top = '20px';
    }, 10);

    // Auto remove after 3 seconds
    setTimeout(() => {
      toast.style.top = '-100px';
      setTimeout(() => {
        toast.remove();
      }, 300); // Wait for slide up animation
    }, 3000);
  }

  /**
   * Schedule reconnection with exponential backoff
   */
  scheduleReconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (max)
    const delay = Math.min(
      INITIAL_RECONNECT_DELAY * Math.pow(2, this.reconnectAttempts),
      MAX_RECONNECT_DELAY
    );

    if (this.errorLogCount < MAX_ERROR_LOGS) {
      console.log(`[HotReload] Reconnecting in ${delay / 1000}s... (attempt ${this.reconnectAttempts + 1})`);
    }

    this.reconnectTimeout = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  /**
   * Send ping to server (optional heartbeat)
   */
  ping() {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));
    }
  }

  /**
   * Disconnect from server
   */
  disconnect() {
    this.isIntentionallyClosed = true;

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    if (this.ws) {
      this.ws.close(1000, 'Client closed');
      this.ws = null;
    }

    console.log('[HotReload] Disconnected');
  }
}

// Singleton instance
let hotReloadClient = null;

/**
 * Initialize hot reload client
 */
export function initHotReload() {
  if (hotReloadClient) {
    console.log('[HotReload] Already initialized');
    return hotReloadClient;
  }

  console.log('[HotReload] üî• Initializing hot reload client...');
  hotReloadClient = new HotReloadClient();
  hotReloadClient.connect();

  // Optional: Send ping every 30 seconds to keep connection alive
  setInterval(() => {
    hotReloadClient.ping();
  }, 30000);

  return hotReloadClient;
}

/**
 * Disconnect hot reload client
 */
export function stopHotReload() {
  if (hotReloadClient) {
    hotReloadClient.disconnect();
    hotReloadClient = null;
  }
}
